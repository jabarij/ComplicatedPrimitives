<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ComplicatedPrimitives</name>
    </assembly>
    <members>
        <member name="T:ComplicatedPrimitives.LimitType">
            <summary>
            Enum indicating whether limit is open or closed.
            </summary>
        </member>
        <member name="F:ComplicatedPrimitives.LimitType.Open">
            <summary>
            Indicates that limit is open which means it does not include the limit value.
            </summary>
        </member>
        <member name="F:ComplicatedPrimitives.LimitType.Closed">
            <summary>
            Indicates that limit is closed which means it includes the limit value.
            </summary>
        </member>
        <member name="T:ComplicatedPrimitives.LimitValue`1">
            <summary>
            Structure representing limit point of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of limit point's value.</typeparam>
        </member>
        <member name="F:ComplicatedPrimitives.LimitValue`1.Infinity">
            <summary>
            Infinite limit point.
            </summary>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.#ctor(`0,ComplicatedPrimitives.LimitType)">
            <summary>
            Creates a new <see cref="P:ComplicatedPrimitives.LimitValue`1.IsFinite">finite</see> instance of the <see cref="T:ComplicatedPrimitives.LimitValue`1"/> structure with a specified <paramref name="value"/> and <paramref name="type"/>.
            </summary>
            <param name="value">Limit point's value.</param>
            <param name="type">Limit point's type.</param>
        </member>
        <member name="P:ComplicatedPrimitives.LimitValue`1.Value">
            <summary>
            Gets the value of this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see>.
            </summary>
            <remarks>
            For <see cref="P:ComplicatedPrimitives.LimitValue`1.IsInfinite">infinite</see> instances of <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see>, the value is always considered to be default of <typeparamref name="T"/>.
            </remarks>
        </member>
        <member name="P:ComplicatedPrimitives.LimitValue`1.Type">
            <summary>
            Gets the value indicating whether this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> is either <see cref="F:ComplicatedPrimitives.LimitType.Open">open</see> or <see cref="F:ComplicatedPrimitives.LimitType.Closed">closed</see>,
            which means - in other words - whether this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> covers it's <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> or considers it unreachable.
            </summary>
            <remarks>
            For <see cref="P:ComplicatedPrimitives.LimitValue`1.IsInfinite">infinite</see> instances of <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see>, the type is always considered to be <see cref="F:ComplicatedPrimitives.LimitType.Open">open</see>.
            </remarks>
        </member>
        <member name="P:ComplicatedPrimitives.LimitValue`1.IsFinite">
            <summary>
            Indicates whether this instance represents a finite <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> with certain <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see>.
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.LimitValue`1.IsInfinite">
            <summary>
            Indicates whether this instance represents an infinite <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see>.
            </summary>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.Map``1(System.Func{`0,``0})">
            <summary>
            Maps this instance to <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> of <typeparamref name="TResult"/> using given <paramref name="mapper"/>.
            </summary>
            <typeparam name="TResult">Target type to map <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> to.</typeparam>
            <param name="mapper">Function that maps value of type <typeparamref name="T"/> to type <typeparamref name="TResult"/>.</param>
            <returns>
            When this instance <see cref="P:ComplicatedPrimitives.LimitValue`1.IsFinite">is finite</see>, new <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> of <typeparamref name="TResult"/>
            with then same <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see>, but with <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> being mapped using given <paramref name="mapper"/>;
            otherwise, <see cref="F:ComplicatedPrimitives.LimitValue`1.Infinity">infinite limit point</see> of <typeparamref name="TResult"/>.
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.Translate(System.Func{`0,`0})">
            <summary>
            Translates (moves) this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> using given <paramref name="translation"/>.
            </summary>
            <param name="translation">Function that translates limit point's value.</param>
            <returns>
            When this instance <see cref="P:ComplicatedPrimitives.LimitValue`1.IsFinite">is finite</see>, new <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> with then same <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see>,
            but with <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> being translated using given <paramref name="translation"/>;
            otherwise, <see cref="F:ComplicatedPrimitives.LimitValue`1.Infinity">infinity</see>.
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.AsOpen">
            <summary>
            Converts this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> to <see cref="F:ComplicatedPrimitives.LimitType.Open">open</see>.
            </summary>
            <returns>
            When this instance <see cref="P:ComplicatedPrimitives.LimitValue`1.IsFinite">is finite</see>, new <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> with the same <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see>,
            but with <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see> equal to <seealso cref="F:ComplicatedPrimitives.LimitType.Open">open</seealso>;
            otherwise, <see cref="F:ComplicatedPrimitives.LimitValue`1.Infinity">infinity</see>.
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.AsClosed">
            <summary>
            Converts this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> to <see cref="F:ComplicatedPrimitives.LimitType.Closed">closed</see>.
            </summary>
            <returns>
            When this instance <see cref="P:ComplicatedPrimitives.LimitValue`1.IsFinite">is finite</see>, new <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> with the same <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see>,
            but with <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see> equal to <seealso cref="F:ComplicatedPrimitives.LimitType.Closed">open</seealso>;
            otherwise, <see cref="F:ComplicatedPrimitives.LimitValue`1.Infinity">infinity</see>.
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.RightContains(`0)">
            <summary>
            Gets the value indicating whether this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> contains the <paramref name="value"/> on it's right side
            or in other words whether <paramref name="value"/> is part of the set limited by this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> from the left side.
            </summary>
            <param name="value">Value to compare with this instance.</param>
            <returns>
            <see langword="true"/> when:
            <list type="bullet">
            <item><description><paramref name="value"/> is greater than this <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> for this <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see> being <seealso cref="F:ComplicatedPrimitives.LimitType.Open">open</seealso>;</description></item>
            <item><description><paramref name="value"/> is greater than or equal to this <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> for this <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see> being <seealso cref="F:ComplicatedPrimitives.LimitType.Closed">closed</seealso>;</description></item>
            <item><description>this instance <see cref="P:ComplicatedPrimitives.LimitValue`1.IsInfinite">is infinite</see>;</description></item>
            </list>
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.LeftContains(`0)">
            <summary>
            Gets the value indicating whether this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> contains the <paramref name="value"/> on it's left side
            or in other words whether <paramref name="value"/> is part of the set limited by this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> from the right side.
            </summary>
            <param name="value">Value to compare with this instance.</param>
            <returns>
            <see langword="true"/> when:
            <list type="bullet">
            <item><description><paramref name="value"/> is lower than this <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> for this <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see> being <seealso cref="F:ComplicatedPrimitives.LimitType.Open">open</seealso>;</description></item>
            <item><description><paramref name="value"/> is lower than or equal to this <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> for this <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see> being <seealso cref="F:ComplicatedPrimitives.LimitType.Closed">closed</seealso>;</description></item>
            <item><description>this instance <see cref="P:ComplicatedPrimitives.LimitValue`1.IsInfinite">is infinite</see>;</description></item>
            </list>
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.ToString">
            <summary>
            Converts this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> to its equivalent string representation.
            </summary>
            <returns>The string representation of this <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> consisting of:
            <list type="bullet">
            <item><description>signs representing <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">type</see> (<c>&gt;</c>, <c>≥</c>, <c>≤</c>, <c>&lt;</c>);</description></item>
            <item><description>string representation of <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">value</see> when this instance <see cref="P:ComplicatedPrimitives.LimitValue`1.IsFinite">is finite</see> or the <see cref="F:ComplicatedPrimitives.LimitValue`1.Infinity">infinity</see> symbol '∞' if it's not.</description></item>
            </list>
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.Equals(ComplicatedPrimitives.LimitValue{`0})">
            <summary>
            Checks whether this instance of <see cref="T:ComplicatedPrimitives.LimitValue`1"/> is equal to the <paramref name="other"/> one.
            </summary>
            <param name="other">Object to check equality with this instance.</param>
            <returns>
            <see langword="true"/> if this instance is equal to the <paramref name="other"/> one which means:
            <list type="bullet">
            <item><description>both instances <see cref="P:ComplicatedPrimitives.LimitValue`1.IsInfinite">are infinite</see>;</description></item>
            <item><description>both instances <see cref="P:ComplicatedPrimitives.LimitValue`1.IsFinite">are finite</see> and their <see cref="P:ComplicatedPrimitives.LimitValue`1.Value">values</see> and <see cref="P:ComplicatedPrimitives.LimitValue`1.Type">types</see> are equal;</description></item>
            </list>
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.op_Equality(ComplicatedPrimitives.LimitValue{`0},ComplicatedPrimitives.LimitValue{`0})">
            <summary>
            Determines whether two specified <see cref="T:ComplicatedPrimitives.LimitValue`1">limit points</see> have the same value.
            </summary>
            <param name="left">The first <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> to compare.</param>
            <param name="right">The second <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> to compare.</param>
            <returns><see langword="true"/> if the value of <paramref name="left"/> is the same as the value of <paramref name="right"/>;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ComplicatedPrimitives.LimitValue`1.op_Inequality(ComplicatedPrimitives.LimitValue{`0},ComplicatedPrimitives.LimitValue{`0})">
            <summary>
            Determines whether two specified <see cref="T:ComplicatedPrimitives.LimitValue`1">limit points</see> have different values.
            </summary>
            <param name="left">The first <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> to compare.</param>
            <param name="right">The second <see cref="T:ComplicatedPrimitives.LimitValue`1">limit point</see> to compare.</param>
            <returns><see langword="true"/> if the value of <paramref name="left"/> is different from the value of <paramref name="right"/>;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:ComplicatedPrimitives.Range`1">
            <summary>
            Readonly structure representing range of comparable values.
            </summary>
            <typeparam name="T">Type of range value (domain).</typeparam>
        </member>
        <member name="F:ComplicatedPrimitives.Range`1.Empty">
            <summary>
            Represents empty range (often described using symbol ∅).
            </summary>
        </member>
        <member name="F:ComplicatedPrimitives.Range`1.Infinite">
            <summary>
            Represents infinite range (often described using symbol (∞;∞)).
            </summary>
        </member>
        <member name="M:ComplicatedPrimitives.Range`1.#ctor(ComplicatedPrimitives.DirectedLimit{`0},ComplicatedPrimitives.DirectedLimit{`0})">
            <summary>
            Creates new range with given limits.
            </summary>
            <param name="left">Left limit of range.</param>
            <param name="right">Right limit of range.</param>
            <exception cref="T:System.ArgumentException">Thrown when:
            <list type="bullet">
            <item><description><paramref name="left"/> limit is of right side;</description></item>
            <item><description><paramref name="right"/> limit is of left side;</description></item>
            <item><description><paramref name="left"/> and <paramref name="right"/> limits don't intersect;</description></item>
            </list>
            </exception>
            <seealso cref="M:ComplicatedPrimitives.DirectedLimit`1.Intersects(ComplicatedPrimitives.DirectedLimit{`0})">Intersecting directed limits.</seealso>
            <seealso cref="P:ComplicatedPrimitives.DirectedLimit`1.Side">Directed limit's side.</seealso>
        </member>
        <member name="M:ComplicatedPrimitives.Range`1.#ctor(ComplicatedPrimitives.LimitValue{`0},ComplicatedPrimitives.LimitValue{`0})">
            <summary>
            Creates new range with given limits.
            </summary>
            <param name="left">Left limit of range.</param>
            <param name="right">Right limit of range.</param>
            <exception cref="T:System.ArgumentException">Thrown when:
            <list type="bullet">
            <item><description><paramref name="left"/> and <paramref name="right"/> limits don't intersect;</description></item>
            </list>
            </exception>
            <seealso cref="M:ComplicatedPrimitives.DirectedLimit`1.Intersects(ComplicatedPrimitives.DirectedLimit{`0})">Intersecting directed limits.</seealso>
        </member>
        <member name="M:ComplicatedPrimitives.Range`1.#ctor(`0,`0,ComplicatedPrimitives.LimitType,ComplicatedPrimitives.LimitType)">
            <summary>
            Creates new range with given limits.
            </summary>
            <param name="left">Value of left limit of range.</param>
            <param name="right">Value of right limit of range.</param>
            <param name="leftLimit">Type of left limit of range.</param>
            <param name="rightLimit">Type of right limit of range.</param>
            <exception cref="T:System.ArgumentException">Thrown when:
            <list type="bullet">
            <item><description><paramref name="left"/> and <paramref name="right"/> limits don't intersect;</description></item>
            </list>
            </exception>
            <seealso cref="M:ComplicatedPrimitives.DirectedLimit`1.Intersects(ComplicatedPrimitives.DirectedLimit{`0})">Intersecting directed limits.</seealso>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.Left">
            <summary>
            Gets the left limit of this range.
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.Right">
            <summary>
            Gets the right limit of this range.
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.LeftValue">
            <summary>
            Gets the value of left limit of this range.
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.RightValue">
            <summary>
            Gets the value of right limit of this range.
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.IsNotEmpty">
            <summary>
            Gets the value indicating whether this instance is not an empty range (∅).
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.IsEmpty">
            <summary>
            Gets the value indicating whether this instance is an empty range (∅).
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.IsInfiniteLeft">
            <summary>
            Gets the value indicating whether left limit is infinite.
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.IsInfiniteRight">
            <summary>
            Gets the value indicating whether right limit is infinite.
            </summary>
        </member>
        <member name="P:ComplicatedPrimitives.Range`1.IsInfinite">
            <summary>
            Gets the value indicating whether this range is of infinite limits.
            </summary>
        </member>
        <member name="M:ComplicatedPrimitives.Range`1.Map``1(System.Func{`0,``0})">
            <summary>
            Functor mapping range's value with special states preservation.
            </summary>
            <typeparam name="TResult">Target type to map value to.</typeparam>
            <param name="mapper">Value mapping function.</param>
            <returns><see cref="T:ComplicatedPrimitives.Range`1"/> with <see cref="P:ComplicatedPrimitives.Range`1.Left"/> and <see cref="P:ComplicatedPrimitives.Range`1.Right"/> limits mapped using <paramref name="mapper"/> function when this instance <see cref="P:ComplicatedPrimitives.Range`1.IsNotEmpty"/>; otherwise <see cref="F:ComplicatedPrimitives.Range`1.Empty"/>.</returns>
        </member>
        <member name="M:ComplicatedPrimitives.Range`1.Contains(`0)">
            <summary>
            Checks if this range contains given <paramref name="value"/> (mathematical equivalent of expression: <paramref name="value"/> ∊ <c>this</c>).
            </summary>
            <param name="value">Value to check inclusion relation of.</param>
            <returns><see langword="true"/> if the <paramref name="value"/> belongs to this range; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:ComplicatedPrimitives.Range`1.Intersects(ComplicatedPrimitives.Range{`0})">
            <summary>
            Checks if this range intersects (has common elements) with given <paramref name="other"/> range (mathematical equivalent of expression: <c>this</c> ∩ <paramref name="other"/> ≠ ∅).
            </summary>
            <param name="other">Other range to check intersection relation with.</param>
            <returns><see langword="true"/> if the <paramref name="other"/> has common elements to this range; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:ComplicatedPrimitives.Range`1.IsSubsetOf(ComplicatedPrimitives.Range{`0})">
            <summary>
            Checks whether <c>this</c> range is a subset of the <paramref name="other"/> range (<c>this</c> ⊆ <paramref name="other"/>).
            </summary>
            <param name="other">Range to check inclusion relation with.</param>
            <returns>
            <see langword="true"/> if this range is a subset of the <paramref name="other"/> range; otherwise <see langword="false"/>.
            </returns>
            <remarks>
            This function checks the weak inclusion relation which means that a range is in a given relation with equal range. To check strict version of this relation (excluding equal ranges), use <see cref="M:ComplicatedPrimitives.Range`1.IsProperSubsetOf(ComplicatedPrimitives.Range{`0})"/>.
            <list type="bullet">
              <listheader>
            	<description>Following conditions apply to this function:</description>
              </listheader>
              <item>
            	<description>(A = B) → (A ⊆ B ⋀ B ⊆ A);</description>
              </item>
              <item>
            	<description>∅ ⊆ A for every range A (especially: ∅ ⊆ ∅);</description>
              </item>
              <item>
            	<description>(∞;∞) ⊈ A for any finite range A;</description>
              </item>
              <item>
            	<description>(∞;∞) ⊆ (∞;∞);</description>
              </item>
            </list>
            </remarks>
        </member>
    </members>
</doc>
